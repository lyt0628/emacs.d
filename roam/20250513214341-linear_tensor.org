:PROPERTIES:
:ID:       4ea57aa6-55d2-4894-97f6-a5b3058c0031
:END:
#+title: linear/tensor

* 张量积
** 解释
张量积就是把两个事物的所有可能性“配对相乘”，生成一个更大的多维表格。
例子1：菜单组合‌

假设去餐厅点餐：

- ‌前菜‌有：汤（A）、沙拉（B）
- ‌主菜‌有：牛排（X）、鱼（Y）、鸡（Z）

它们的 ‌组合菜单（外积）‌ 就是所有可能的搭配：
#+BEGIN_SRC plantuml :file tmp/0db2b454-7519-4285-9fdf-23e477b25439.png
  @startuml
salt
{
  {T
    +-----+-----+-----+
    | 前菜 | 主菜 | 组合 |
    +-----+-----+-----+
    | 汤   | 牛排 | AX  |
    +-----+-----+-----+
    | 汤   | 鱼   | AY  |
    +-----+-----+-----+
    | 汤   | 鸡   | AZ  |
    +-----+-----+-----+
    | 沙拉 | 牛排 | BX  |
    +-----+-----+-----+
    | 沙拉 | 鱼   | BY  |
    +-----+-----+-----+
    | 沙拉 | 鸡   | BZ  |
    +-----+-----+-----+
  }
}
@enduml

#+END_SRC

#+RESULTS:
[[file:tmp/0db2b454-7519-4285-9fdf-23e477b25439.png]]

场景2：生成游戏地图‌

- ‌横向地形‌：草原、沙漠、雪地（3种）
- ‌纵向地形‌：平原、山地、峡谷（3种）

它们的 ‌外积‌ 就是所有可能的拼接地形：
草原+平原、草原+山地、草原+峡谷  
沙漠+平原、沙漠+山地、沙漠+峡谷  
雪地+平原、雪地+山地、雪地+峡谷  

** 计算
向量外积‌ → 二维表格（矩阵）
‌矩阵外积‌ → 四维立方体（难以可视化，但数学上存在）
‌通用规则‌：两个张量的外积维度 = 原维度之和

#+BEGIN_SRC plantuml :file tmp/fbc2addd-4ce7-4845-9f1d-4e2642333fe1.png
@startuml
salt
{
  {T
    +----------------------+----------------------+
    | 张量积（外积）        | 点积（内积）          |
    +----------------------+----------------------+
    | **目的**             | **目的**             |
    +----------------------+----------------------+
    | 扩展维度，生成所有组合 | 收缩维度，计算相似性   |
    +----------------------+----------------------+
    | **操作**             | **操作**             |
    +----------------------+----------------------+
    | 所有元素两两相乘      | 对应元素相乘后求和      |
    +----------------------+----------------------+
    | **结果**             | **结果**             |
    +----------------------+----------------------+
    | 维度更高（向量→矩阵）  | 维度更低（向量→标量）   |
    +----------------------+----------------------+
  }
}
@enduml

@enduml

#+END_SRC

#+RESULTS:
[[file:tmp/fbc2addd-4ce7-4845-9f1d-4e2642333fe1.png]]

** 定义
设张量 AA 和 BB 分别为 mm 阶和 nn 阶张量，其外积 A $\otimes$ B 的分量定义为
#+BEGIN_SRC latex :results file
$$
(\mathcal{A} \otimes \mathcal{B})_{i_1, \dots, i_m, j_1, \dots, j_n} = \mathcal{A}_{i_1, \dots, i_m} \cdot \mathcal{B}_{j_1, \dots, j_n}
$$
#+END_SRC

#+RESULTS:
[[file:c:/Users/ASUS/AppData/Local/Temp/babel-G8sf0q//D9PDqe-1.png]]

例子： 向量的张量积为矩阵
#+BEGIN_SRC latex :results file
  Given $\mathbf{u} = \begin{bmatrix} u_1 \\ u_2 \end{bmatrix}$ and $\mathbf{v} = \begin{bmatrix} v_1 \\ v_2 \end{bmatrix}$, then:

  $$
  \mathbf{u} \otimes \mathbf{v} = 
  \begin{bmatrix}
    u_1v_1 & u_1v_2 \\
    u_2v_1 & u_2v_2
  \end{bmatrix}
  $$
#+END_SRC

#+RESULTS:
[[file:c:/Users/ASUS/AppData/Local/Temp/babel-G8sf0q//uruACd-1.png]]

* 张量转置
在多维中交换轴的顺序
示例‌：三维张量形状为 [层, 行, 列]，转置后可能变为 [列, 行, 层].
矩阵转置是张量转置的特例。
我们把张量积看作是组合，类似的，我们把转置看作是分类

假设你管理 ‌3个超市‌ ，
每个超市有 ‌4种商品分类‌（饮料、零食、日用品、冷冻食品），
每个分类下有 ‌12个月‌ 的销售数据。

我们用三维张量表示这个数据，形状为：

‌(超市数量, 商品分类, 月份) = (3, 4, 12)‌
如果我们想‌改变分析数据的视角‌，比如希望‌按「月份」优先观察不同分类的销售趋势‌，可以将原始张量的两个维度交换：
‌转置前‌：(超市, 分类, 月份)
‌转置后‌：(超市, 月份, 分类)
形状变为 ‌(3, 12, 4)‌，相当于调整了维度顺序
‌数据的物理存储不变‌，但‌访问逻辑改变‌：
- 转置前：
  data[超市A, 饮料, 1月] → 直接找到超市A的饮料1月销量
- 转置后：
  data[超市A, 1月, 饮料] → 需要先定位到“1月”，再找“饮料”


假设我们有三个分类标签
[A, B, C]
[X, Y, Z]
[1, 2, 3]

(a,b,c) 三元组表示在各个分类标签的下标, 如 a=0 表示 类别A, b = 1 表示类别 Y.
我们想在内存中找到 （B, Y, 2） 就需要在 走完一遍 ABC 标签, 再走完一遍 XYZ 标签,然后 走两格 123标签.

我们把 二维数组作一维保存时候, 先访问行在访问列，访问元素的公式为 (nrow -1) * col_count + ncol. 
如果把访问顺序改变，就是转置，那么访问公式就变成了 (ncol -1) * row_count + nrow.
访问原本的 (1, 3) 元素就是现在的访问(3, 1) 元素.

拓展到上面的例子，比如 先访问 ABC，再访问XYZ， 最后访问 123， 就是
(nabc - 1) * (xyz_count * 123_count) + (nxyz -1) * 123_count + n123.

然而, 在执行数学运算时，我们简单地用 下标的元组 表示一次访问, 我们并不在乎每个下标的含义.
因此就没有了所谓的访问公式. 我们想要得到转置的效果就只能改变元素在内存中的排布.
使得它能满足转置的要求.

如，给定张量
[
 1, 2, 3
 4, 5, 6
]
我用元组 (1, 0) 来访问. 以 先访问行再访问列的顺序 为 2.
以先访问列在访问行的顺序 为 4.

如果我们按行优先的顺序构建矩阵，默认的访问值就是 2.
在转置后，应该访问为 4. 我们想达到这个效果,就只能对内存进行"转置".
按先列后行的顺序重新排布内存
[
 1,4,
 2,5,
 3,6,
]

* 收缩

收缩就是沿着一个方向把空间压扁，把这个方向在其他方向的投影积累起来.

考虑下面这个表. 本质上，我们把它看作三维张量 (张三, 红烧肉，2)
| 顾客 | 菜品    | 数量 |
|-----+--------+-----|
| 张三 | 红烧肉  |   2 |
| 张三 | 清蒸鱼  |   1 |
| 李四 | 红烧肉  |   3 |
| 李四 | 麻婆豆腐 |   2 |

写作二维表的格式, 这使得我们最为关注掉数量这个概念，作为值.
|     | 红烧肉 | 清蒸鱼 | 麻婆豆腐 |
|-----+-------+-------+--------|
| 张三 |     2 |     1 |      0 |
| 李四 |     3 |     0 |      2 |

现在我们在 菜品这个维度压缩, 想象一张手，从右边将二维表往左推。
最终成为这个样子
|     | 菜品 |
|-----+-----|
| 张三 | 3   |
|-----+-----|
| 李四 |  5  |

在写作张量的形式，(张三，3). 现在我们压缩了菜品这个维度，
原本菜品维度的数量分布都被积累起来了.
我把被关注概念称为值或者分布值, 被压缩的维度称为压缩轴或者是分布轴.



在一维，我们以班级成绩为例子
成绩=[85,90,78]
我们的分布值为成绩, 分布轴为各个学生
写作表的形式
|-------+----|
| 学生 A | 85 |
|-------+----|
| 学生 B | 90 |
|-------+----|
| 学生 C | 78 |
|-------+----|

我们往学生这个轴向压缩, 其结果为所有学生成绩的求和.


二维就请回顾前面菜品的例子.

三维上，我们以图像颜色转灰度为例子
我们把图像看作三维张量 (宽度，高度，rgb通道),
分布值为给定宽度高度的像素在特定通道的值.
我们在颜色通道这个维度进行压缩.

前面我们所举的例子都是单个表内部的压缩.

多表与单表的区别在于存在多个分布值，不同表的分布值是不一样的.

拿购买商品为例子.
用户-商品购买矩阵‌ AA（形状：2用户 × 3商品), 分布值为购买个个数.
商品-特征矩阵‌ BB（形状：3商品 × 2特征）, 分布值为特征的强度.

我们做矩阵乘法，把商品维度压缩掉.两个表的分布值通过乘积累加 积累了起来.
但是，把购买的个数和特征强度积累在一起一般不具备可解释性.
只能表示一种趋势或者可能性，在这个例子中，如果特征都是诸如，保质期，营养含量之类的好东西的话，
我们的新的分布值就可以称为 用户购买到好货的可能性 或者简单将 用户眼光怎么样.

